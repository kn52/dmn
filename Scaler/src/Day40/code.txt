Q1. Sorted Insert Position
public class Solution {
    public int searchInsert(ArrayList<Integer> A, int B) {
        int l=0;
        int r = A.size()-1;
        while(l<=r){
            int mid=(l+r)/2;
            if(A.get(mid)==B){
                return mid;
            }
            if(A.get(mid)<B){
                l=mid+1;
            }
            else {
                r=mid-1;
            }
        }
        return l;
    }
}


Q2. Search for a Range
public class Solution {
    public int[] searchRange(final int[] A, int B) {
        int n=A.length;
        int k = B;
        int flag=0;
        int[] res=new int[2];
        for(int i=0;i<2;i++){
           int l=0,h=n-1,ans=-1;
        while(l<=h){
            int m=(l+h)/2;
            if(A[m]==k){
                ans=m;
                if(flag==0)
                    h=m-1;
                else
                    l=m+1;
            }
            else if(A[m]<k)
                l=m+1;
            else
                h=m-1;
                }
            res[i]=ans;
            flag=1;
        }
        return res;
    }
}


Q3. Find a peak element
public class Solution {
    public int solve(int[] A) {
        int n = A.length;
         if(n==1){
            return A[0];
        }
        if(A[0]>A[1]){
            return A[0];
        }
        if(A[n-1]>=A[n-2]){
            return A[n-1];
        }
        int h = n - 2;
        int l = 1;
        while (l <= h) {
            int mid = (l+h)/2;
            if (A[mid] > A[mid - 1] && A[mid] > A[mid + 1]) {
                return A[mid];
            }
            else if (A[mid] > A[mid - 1]) {
                l = mid + 1;
            } 
            else {
                h = mid - 1;
            }
        }
        return -1;
    }
}


Q4. Single Element in Sorted Array
public class Solution {
    public int solve(int[] A) {
        int n = A.length;
        if (n == 1) {
            return A[0];
        }
        if (A[0] != A[1]) {
            return A[0];
        }
        if (A[n - 2] != A[n - 1]) {
            return A[n - 1];
        }
        int l = 0;
        int h = n - 1;
        while (l <= h) {
            int mid = (l + h) / 2;
            int _out = mid;
            if (A[mid - 1] != A[mid] && A[mid] != A[mid + 1]) {
                return A[mid];
            } else if (A[mid] == A[mid - 1]) {
                 _out = mid - 1;
            } else if (A[mid] == A[mid + 1]) {
                _out = mid;
            }
            if (_out % 2 == 0) {
                l = mid + 1;
            } else {
                h = mid - 1;
            }
        }
        return -1;
    }
}